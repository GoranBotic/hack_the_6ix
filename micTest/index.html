<audio id="player" controls></audio>
<script>
    const handleSuccess = function(stream) {
      const context = new AudioContext();
      const source = context.createMediaStreamSource(stream);
      const processor = context.createScriptProcessor(8192, 1, 1);
  
      source.connect(processor);
      processor.connect(context.destination);
  
      processor.onaudioprocess = function(e) {

        wav = bufferToWave(e.inputBuffer, e.inputBuffer.length)

        console.log(wav)

        // const form = document.createElement('form');
        // form.method = "POST";
        // form.action = "http://localhost:4500/api/v1/analyze";
        // const input = document.createElement('input');
        // input.type="hidden"
        // input.name="audio" 
        // input.value=URL.createObjectURL(wav) 
        // input.type="file"
        // form.appendChild(input)
        // document.body.appendChild(form)
        // form.submit();

        var xhr = new XMLHttpRequest();
        xhr.open("POST", 'http://localhost:4500/api/v1/analyze', true);

        // // //Send the proper header information along with the request
        xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

        xhr.onreadystatechange = function() { // Call a function when the state changes.
            if (this.readyState === XMLHttpRequest.DONE) {
                console.log(this)
            }
        }
        // //formData = new FormData();
        // // //formData.append('audio', 'words.wav')
        // //formData.append('audio', wav);
        // reader = new FileReader();
        
        // reader.onloadend = function() {
        //     var base64data = reader.result;   
        //     xhr.send("audio="+base64data);             
        //     console.log(base64data);
        // }
        // reader.readAsDataURL(wav) 
        xhr.send('audio='+arrayBufferToBase64(wav))
        //xhr.send(wav)
        // // xhr.send(new Int8Array()); 
        // // xhr.send(document);
        
        };
    };
  
    navigator.mediaDevices.getUserMedia({ audio: true, video: false })
        .then(handleSuccess);


    // Convert AudioBuffer to a Blob using WAVE representation
    function bufferToWave(abuffer, len) {
        var numOfChan = abuffer.numberOfChannels,
        length = len * numOfChan * 2 + 44,
        buffer = new ArrayBuffer(length),
        view = new DataView(buffer),
        channels = [], i, sample,
        offset = 0,
        pos = 0;

        // write WAVE header
        setUint32(0x46464952);                         // "RIFF"
        setUint32(length - 8);                         // file length - 8
        setUint32(0x45564157);                         // "WAVE"

        setUint32(0x20746d66);                         // "fmt " chunk
        setUint32(16);                                 // length = 16
        setUint16(1);                                  // PCM (uncompressed)
        setUint16(numOfChan);
        setUint32(abuffer.sampleRate);
        setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
        setUint16(numOfChan * 2);                      // block-align
        setUint16(16);                                 // 16-bit (hardcoded in this demo)

        setUint32(0x61746164);                         // "data" - chunk
        setUint32(length - pos - 4);                   // chunk length

        // write interleaved data
        for(i = 0; i < abuffer.numberOfChannels; i++)
            channels.push(abuffer.getChannelData(i));

        while(pos < length) {
            for(i = 0; i < numOfChan; i++) {             // interleave channels
                sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp
                sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; // scale to 16-bit signed int
                view.setInt16(pos, sample, true);          // write 16-bit sample
                pos += 2;
            }
            offset++                                     // next source sample
        }

        // create Blob
        //return new Blob([buffer], {type: "audio/wav"});
        return buffer

        function setUint16(data) {
            view.setUint16(pos, data, true);
            pos += 2;
        }

        function setUint32(data) {
            view.setUint32(pos, data, true);
            pos += 4;
        }
    }

    function arrayBufferToBase64( buffer ) {
    var binary = '';
    var bytes = new Uint8Array( buffer );
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode( bytes[ i ] );
    }
    return window.btoa( binary );
}
</script>